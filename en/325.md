325
===

325 is a proprietary file format used by a multi line text panel called SPECTRUM. The display has 15 rows by 30 columns and it hangs out at a few schools and canteens here in the Czech Republic. So instead of dull data like opening hours wouldn't it be nice to have a room schedule displayed there? Whoa, not so fast!

![the SPECTRUM display](d/display.jpg)

The display needs to load all the files at once. That means we use [Windows Task Scheduler](https://en.wikipedia.org/wiki/Windows_Task_Scheduler) to run a *yet to be written* script every morning just before classes start. Finally we do `spectrum.exe` and site's live!

BAT file may go like this:

    @echo off
    title classes

    rem UPDATE
    cd\classes\
    perl.exe classes.pl 2>err.txt

    rem LOAD
    cd\panel\sendpanel
    keybuf.exe /zeeeey
    spectrum.exe
    time /t >log.txt

`keybuf.exe` is a DOS keyboard buffer which simulates a key press. Colleague of mine wrote this. `eeeey` is a sequence of chars that reloads the text panel with just updated files.

![spectrum.exe](d/spectrum.png)

Files are `0730.325, 0915.325, 1100.325, 1245.325, 1430.325, 1615.325 and 1800.325`. You're right, these're classes start times. Now, where's the actual data, i.e. subjects, teachers, rooms and times? Luckily the [university information system](http://www.uis-info.com/en/index) we use has an [API](https://en.wikipedia.org/wiki/Web_API). You request a given URL with a room id as a parameter and get the room schedule for today. And because the world isn't perfect, it's not [JSON](https://developer.mozilla.org/en-US/docs/Glossary/JSON) but HTML. So we'll do [web scraping](https://en.wikipedia.org/wiki/Web_scraping). The SPECTRUM text panel has of course it's own [charset table](https://en.wikipedia.org/wiki/ASCII#ASCII_printable_code_chart) to display czech chars and not exceed one byte. So we ought to remap non-ASCII chars and output bytes. So [pick the right tool for the job](http://c2.com/cgi/wiki?PickTheRightToolForTheJob). We'll do some [Perl](http://qntm.org/files/perl/perl.html)!

On GNU/Linux you're all set, but on Windows [Perl has to be installed](http://dwimperl.com/windows.html) first. We also install the [`LWP::Simple`](https://metacpan.org/pod/LWP::Simple) module to send [HTTP requests](https://pretty-rfc.herokuapp.com/RFC2616#GET) and to keep it *simple* at the same time. The following will do it:

    % cpan LWP::Simple

OK, the `classes.pl` script checklist is:

- 0
  - download schedule for given classrooms
  - extract data, purify and parse teacher' surname
- 1
  - store that in a right data structure (hash of hashes)
  - iterate over and prepare the display screens
- 2
  - ensure the `*.325` format
  - encode (or replace) chars beyond ASCII
  - write files

Our first lines of Perl are:

    use strict;
    use warnings;
    use LWP::Simple;
    use File::Spec;
    #use Data::Dumper;
    use utf8;

    # CHANGELOG
    # v1, 08/2015, Your Name

    # TODO
    # -

The script is used for a particular floor, 5 classrooms there. Then the chosen display format is:

    /NOW/
    ROOM  SubjID SURNAME(of teachers)
    5x

    /NEXT/
    ROOM  SubjID SURNAME(of teachers)
    5x

So *start times* and *classrooms* are known. We can write like this:

    ### ============== MAIN =============
    use constant API
        # live
        => 'http://REDACTED/?room='
        # debug
        # => 'http://localhost:8080/classes.html?'
    ;
    use constant CLASSES
        => qw( 7:30 9:15 11:00 12:45 14:30 16:15 18:00 19:45 )
    ;
    my %room = (
                # room id
        'JM 357'  => 752,
        'JM 359'  => 746,
        'JM 360'  => 2281,
        'JM 361'  => 790,
        'JM 382'  => 700,
    );

    print_panels(classes(values %room));
    ### ============ END ================

You might have noticed we added URL of API and already called subroutines *from the future*. Well, here's `sub classes {`:

    =head2 classes

    gets the room schedules for today

     Returns : %class_ref
     Args    : @ucebny

    =cut

    sub classes {
        my @rooms_id = @_;

        my %class;
        for my $room (@rooms_id) {
            # HTTP GET :iso-8859-2
            my $html = do {
                my $r;
                # 3 attempts to connect
                for (1..3) {
                  $r = get(API . $room);
                  last if $r;
                }

                $r;
            };
            die "(!) can't connect\n" unless $html;

            for my $_class (_html($html)) {
                my @subject = @{ $_class };

                my $time = shift @subject;
                my $subj = join ' ', @subject;
                # remove white space
                $subj =~ s/^\s+|\s+$//g;

                $class{$time}{$room} = $subj;
            }
        }

        return \%class;
    }

From there we call `sub _html` which extracts data from HTML, so let's have a look at that HTML source:

    <table>
    <thead>
    <tr>
    <th><small>From</small></th>
    <th><small>To</small></th>
    <th><small>Room</small></th>
    <th><small>SubjID</small></th>
    <th><small>Subject</small></th>
    <th><small>Teacher</small></th>
    </tr>
    </thead>
    <tr>
    <td><small>9:15</small></td>
    <td><small>10:45</small></td>
    <td><small>ZB 243 (ZB)</small></td>
    <td><small>4CS101</small></td>
    <td><small>Introduction to Computer Science</small></td>
    <td><small>Ph.D. John Doe, MBA</small></td>
    </tr>
    </table>

Not so bad, I'm sure we can parse it with a little help of [regex](https://www.cs.tut.fi/~jkorpela/perl/regexp.html):



These're our data:

! source HTML nebo printscreen

